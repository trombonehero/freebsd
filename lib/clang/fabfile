# $FreeBSD$

# Be a bit explicit about what kind of toolchain we expect to be passed.
Toolchain = type record[c:record[], shell:record[], tblgen:record[]];
toolchain:Toolchain = args.toolchain;

llvmroot = subdir.subdir.subdir ::: 'contrib' ::: 'llvm';
llvminclude = llvmroot ::: 'include' ::: 'llvm';
llvmlibdir = llvmroot :: 'lib';
gendir = toolchain.shell.mkdir(builddir, 'gen');

#
# TODO: build these options dynamically
#
llvm_options:toolchain.c.compiler_options = record
{
	debug = false;

	definitions =
	[
		'LLVM_BUILD_GLOBAL_ISEL'
		'LLVM_DEFAULT_TARGET_TRIPLE=\"x86_64-unknown-freebsd13.0\"'
		'LLVM_HOST_TRIPLE=\"x86_64-unknown-freebsd13.0\"'
		'LLVM_NATIVE_ASMPARSER=LLVMInitializeX86AsmParser'
		'LLVM_NATIVE_ASMPRINTER=LLVMInitializeX86AsmPrinter'
		'LLVM_NATIVE_DISASSEMBLER=LLVMInitializeX86Disassembler'
		'LLVM_NATIVE_TARGET=LLVMInitializeX86Target'
		'LLVM_NATIVE_TARGETINFO=LLVMInitializeX86TargetInfo'
		'LLVM_NATIVE_TARGETMC=LLVMInitializeX86TargetMC'
		'LLVM_TARGET_ENABLE_X86'
		'__STDC_CONSTANT_MACROS'
		'__STDC_LIMIT_MACROS'
	];

	flags =
	[
		'-pipe'
		'-fdata-sections'
		'-ffunction-sections'
		'-fno-exceptions'
		'-fno-rtti'
		'-gline-tables-only'
		'-stdlib=libc++'
	];

	optlevel = 2;
	pic = false;
	standard = 'c++11';

	include_dirs =
	{
		subdir = subdir.subdir.subdir;

		[
			llvmroot + '/include'
			file('lib/clang/include')
			gendir
			{ (gendir :: 'llvm') :: 'IR' }
		]
	};

	sanitizer = '';

	system_include_dirs = [];

	warnings = ['all'];
};

tblgen = function(source:file, output:file, gen_action:string): file
{
	flags = [gen_action] + ['-I'] + [(llvmroot :: 'include').fullname];

	toolchain.tblgen.llvm(source, output, flags)
};


options = record
{
	#
	# TODO: decipher these
	#
	bootstrap = true;   # (defined(TOOLS_PREFIX) && ${MK_LLD_BOOTSTRAP} != "no")
	lldb = true;    # MK_LLDB

	#SRCS_ALL+=	${SRCS_MIN}
	#.if !defined(TOOLS_PREFIX) || ${MK_LLD_BOOTSTRAP} != "no"
	#SRCS_ALL+=	${SRCS_MIW}
	#.endif
	miw = true;   #.if !defined(TOOLS_PREFIX) || ${MK_LLD_BOOTSTRAP} != "no"

	#.if ${MK_CLANG_EXTRAS} != "no"
	#SRCS_ALL+=	${SRCS_EXT}
	#.endif
	clang_extras = true;   # MK_CLANG_EXTRAS

	#.if ${MK_CLANG_FULL} != "no"
	#SRCS_ALL+=	${SRCS_FUL}
	#.endif
	clang_full = true;     # MK_CLANG_FULL

	#.if ${MK_LLD} != "no" || \
	#    (defined(TOOLS_PREFIX) && ${MK_LLD_BOOTSTRAP} != "no")
	#SRCS_ALL+=	${SRCS_LLD}
	#.endif
	lld = true;     # ${MK_LLD} != "no" 

	#.if ${MK_CLANG_EXTRAS} != "no" || ${MK_LLD} != "no" || \
	#    (defined(TOOLS_PREFIX) && ${MK_LLD_BOOTSTRAP} != "no")
	#SRCS_ALL+=	${SRCS_EXL}
	#.endif
	exl = clang_extras or lld;

	#.if ${MK_CLANG_EXTRAS} != "no" || ${MK_LLDB} != "no"
	#SRCS_ALL+=	${SRCS_XDB}
	#.endif
	xdb = clang_extras or lldb;

	#.if ${MK_CLANG_EXTRAS} != "no" || ${MK_LLDB} != "no" || ${MK_LLD} != "no" || \
	#    (defined(TOOLS_PREFIX) && ${MK_LLD_BOOTSTRAP} != "no")
	#SRCS_ALL+=	${SRCS_XDL}
	#.endif
	xdl = clang_extras or lldb or lld or bootstrap;

	#.if ${MK_CLANG_EXTRAS} != "no" || ${MK_LLDB} != "no" || !defined(TOOLS_PREFIX)
	#SRCS_ALL+=	${SRCS_XDW}
	#.endif
	#SRCS+=		${SRCS_ALL:O}
	xdw = clang_extras or lldb or true;   # || !defined(TOOLS_PREFIX)
};



llvm = import('libllvm', options=options);

srcs = llvm.sources;
generated_headers = llvm.generated_headers;

objs = toolchain.c.compile(srcs, llvm_options, dependencies=generated_headers);
#lib = toolchain.c.static_library(objs, 'llvm', subdir);
