# vim: sw=4:ts=4:tw=78
# $FreeBSD$

build = opts.llvm.targets;

if not (build.aarch64 or build.arm or build.bpf or build.mips
	or build.powerpc or build.riscv or build.sparc or build.x86)
{
	# TODO: error() once fabrique issue #48 is resolved
	print('No LLVM targets specified')
}
else [];


# Specify where generated files will be built (and included from)
target_dir = llvmlibdir :: 'Target';

# Provide an explicit representation of the type that's used to represent
# all possible llvm-tblgen rules (not all of which are used by every target)
TargetTblGenRules = type record
[
	generated_include_dir:file,

	asmMatcher:()->file,
	asmWriter:()->file,
	asmWriter1:()->file,
	callingConv:()->file,
	codeEmitter:()->file,
	compressedInstEmitter:()->file,
	disassembler:()->file,
	evex2vex:()->file,
	instrInfo:()->file,
	isel:record[],
	mc:record[emitter:()->file, pseudoLowering:()->file],
	reg:record[bank:()->file, info:()->file],
	subtarget:()->file,
	system:record[operands:()->file, register:()->file],
];

#
# Create a record that can generate standard target include files using
# LLVM tblgen.
#
# There is a well-defined set of names that can be used by targets, but not
# every target uses every name. This function returns a data structure that
# can generate target includes when its methods (closures) are invoked.
# For example, a target that only generates ASM-related includes could say:
#
# ```
# rules = target_tblgen_rules('MyTargetName');
# generated_headers = [ rules.asmMatcher() rules.asmWriter() ];
# ```
#
target_tblgen_rules = function(arch:string): TargetTblGenRules
{
	# LLVM targets are built in well-defined locations with well-defined names
	archdir = target_dir :: arch;
	tblgen_src = { subdir = archdir; file(arch + '.td') }; # TODO: Issue #51

	# Find a generated output file (e.g., AArch64GenAsmMatcher.inc)
	outfile = function(name:string): file
	{
		file(arch + 'Gen' + name + '.inc')
	};

	# Create a function that, if invoked, will generate a specific
	# tblgen rule (e.g., "build AsmMatcher")
	builder = function(target:string, gen_action:string): ()->file
	{
		function(): file
		{
			toolchain.tblgen.llvm(source=tblgen_src, output=outfile(target),
			                      flags=['-gen-' + gen_action],
			                      includes=[llvmroot::'include' archdir])
		}
	};

	record
	{
		# The directory that generated files will end up in
		generated_include_dir:file = archdir;

		asmMatcher = builder('AsmMatcher', 'asm-matcher');
		asmWriter = builder('AsmWriter', 'asm-writer');
		asmWriter1 = builder('AsmWriter1', 'asm-writer -asmwriternum=1');
		callingConv = builder('CallingConv', 'callingconv');
		codeEmitter = builder('CodeEmitter', 'emitter');
		compressedInstEmitter =
			builder('CompressInstEmitted', 'compress-inst-emitter');
		disassembler = builder('DisassemblerTables', 'disassembler');
		evex2vex = builder('EVEX2VEXTables', 'x86-EVEX2VEX-tables');
		instrInfo = builder('InstrInfo', 'instr-info');
		isel = record
		{
			dag = builder('DAGISel', 'dag-isel');
			fast = builder('FastISel', 'fast-isel');
			global = builder('GlobalISel', 'global-isel');
		};
		mc = record
		{
			emitter = builder('MCCodeEmitter', 'emitter');
			pseudoLowering = builder('MCPseudoLowering', 'pseudo-lowering');
		};
		reg = record
		{
			bank = builder('RegisterBank', 'register-bank');
			info = builder('RegisterInfo', 'register-info');
		};
		subtarget = builder('SubtargetInfo', 'subtarget');
		system = record
		{
			operands = builder('SystemOperands', 'searchable-tables');
			register = builder('SystemRegister', 'searchable-tables');
		};
	}
};

sources =
	{
		subdir = target_dir;

		files(
			Target.cpp TargetIntrinsicInfo.cpp TargetLoweringObjectFile.cpp
			TargetMachine.cpp TargetMachineC.cpp
		)
	}
	;

currently_ignored_sources =
	+ (if build.aarch64 import('AArch64.fab').sources else [])
	+ (if build.arm import('ARM.fab').sources else [])
	+ (if build.bpf import('BPF.fab').sources else [])
	+ (if build.mips import('Mips.fab').sources else [])
	+ (if build.powerpc import('PowerPC.fab').sources else [])
	+ (if build.riscv import('RISCV.fab').sources else [])
	+ (if build.sparc import('Sparc.fab').sources else [])
	+ (if build.x86 import('X86.fab').sources else [])
	;
