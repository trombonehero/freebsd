#
# Description of how to compile things with "GCC-like" compilers (GCC, Clang, others?)
#

# Get information about the current platform (POSIX? Darwin? Windows?)
platform = args.platform ? import('platform');

toolchain = import('toolchain.fab');
Options = toolchain.Options;

default_options:Options = record
{
	debug = false;
	definitions = [];
	cflags = [];
	cxxflags = [];
	include_dirs = [];
	optlevel = 2;
	pic = true;
	sanitizer = '';

	system_include_dirs =
		if platform.darwin files()
		else if platform.posix files(/usr/include)
		else files()
		;

	warnings = [];
};


compile_flags = function(opts:Options, cxx:bool=false,
                         extra_header_dirs:list[file]=[]): list[string]
{
	include_dirs = opts.include_dirs + extra_header_dirs;

	(if opts.debug '-g' else '')
	::
	('-O' + string(opts.optlevel))
	::
	(if opts.pic '-fPIC' else '')
	::
	(if opts.sanitizer != '' ['-fsanitize=' + opts.sanitizer] else [])
	+
	(if cxx opts.cxxflags else opts.cflags)
	+
	(for dir in include_dirs '-I' + dir.fullname)
	+
	(for dir in opts.system_include_dirs '-isystem ' + dir.fullname)
	+
	(for warning in opts.warnings '-W' + warning)
	+
	(for define in opts.definitions '-D' + define)
};

binary_flags = function(opts:Options, cxx:bool, libraries:list[string]=[],
                        dynamic:bool=false): list[string]
{
	(if opts.debug ['-g'] else [])
	+
	(if opts.sanitizer != '' ['-fsanitize=' + opts.sanitizer] else [])
	+
	(if dynamic and platform.posix ['-rdynamic'] else [])
	+
	(for lib in libraries '-l' + lib)
};

library_flags = function(shared_library:bool): list[string]
{
	(if platform.darwin ['-Wl,-undefined' '-Wl,dynamic_lookup'] else [])
	+
	(if shared_library ['-shared'] else [])
};


#
# Link objects into an executable binary.
#
binary = function(compiler:file, objects:list[file[in]], binary:file[out],
                  options:Options, libraries:list[string]=[],
                  extra_flags:list[string]=[], cxx:bool=false): file
{
	flags = binary_flags(options, libraries);
	compiler = if cxx compilers.cxx else compilers.cc;

	gcc.link_binary(compiler, objects, binary, linker_flags+flags)
};


#
# Compile objects into a shared library given by libname (e.g., `foo` for `libfoo.so`).
#
library = function(compiler:file, objects:list[file], libname:string, subdir:file,
                   shared:bool, extra_flags:list[string]=[]): file
{
	filename = file(library_name(libname), subdir=subdir);
	flags = library_flags(shared) + extra_flags;

	link_library(compiler, objects, filename, flags)
};


#
# What should a library be called on this platform?
#
library_name = function(name:string): string
{
	if platform.darwin
		'lib' + name + '.dylib'

	else if platform.posix
		'lib' + name + '.so'

	else
		name + '.dll'
};


#
# Where supported, treat system header directories differently from other include dirs:
# suppress warnings in files that we aren't responsible for.
#
system_headers = function(dirs:list[file]): list[string]
{
	for dir in dirs
	{
		'-isystem ' + dir.fullname
	}
};


#
# Create a GCC-like toolchain.
#
create_toolchain = function(compilers:toolchain.Compilers,
                            extra_compile_flags:list[string],
                            extra_linker_flags:list[string]): toolchain.Toolchain
{
	compile_src = function(src:file[in], options:Options, depends:list[file[in]]): file
	{
		cxx = not src.extension == 'c';
		compiler = if cxx compilers.cxx else compilers.cc;
		flags = compile_flags(options, cxx) + extra_compile_flags;

		obj = src + '.o';
		compile_one(compiler, src, obj, flags, depends);

		# Let the result be the generated file rather than the action that built it
		obj
	};

	binflags = function(opts:Options, cxx:bool): list[string]
	{
		# TODO: don't assume dynamic binaries
		binary_flags(opts, cxx, true) + extra_linker_flags
	};

	libflags = function(opts:Options, cxx:bool): list[string]
	{
		(if opts.debug ['-g'] else [])
		+
		(if platform.darwin ['-Wl,-undefined' '-Wl,dynamic_lookup'] else [])
		+
		['-shared']
	};

	toolchain.create(compilers, default_options, compile_src, binflags, libflags)
};


#
# Low-level rules:
#

# Compile one source file into one object file.
compile_one = action('${compiler} -c ${flags} -MMD -MF ${obj}.d ${src} -o ${obj}',
	     description='Compiling ${obj}', depfile='${obj}.d', deps='gcc'
	     <- compiler:file[in], src:file[in], obj:file[out], flags:list[string],
	        otherDeps:list[file[in]] = [], dependencies:string = '');

# Link object files into an executable binary.
link_binary = action(
	'${compiler} -o ${binary} ${objects} ${flags}', description = 'Linking ${binary}'
	<- compiler:file[in], objects:list[file[in]], binary:file[out], flags:list[string]
);

# Low-level rule for compiling objects into a shared library.
link_library = action(
	'${compiler} -shared -o ${library} ${objects} ${flags}',
	description = 'Linking ${library}'
        <- compiler:file[in], objects:list[file[in]], library:file[out],
	   flags:list[string]);
