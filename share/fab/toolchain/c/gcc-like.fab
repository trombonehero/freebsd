#
# Description of how to compile things with "GCC-like" compilers (GCC, Clang, others?)
#


#
# A GCC-like compiler toolchain must have both a C and a C++ compiler.
#
Compilers = type record[cc:file, cxx:file];


#
# Options represent compiler flags in a more structured way.
#
Options = type record
[
	debug:bool,
	definitions:list[string],
	cflags:list[string],
	cxxflags:list[string],
	include_dirs:list[file],
	optlevel:int,
	pic:bool,
	sanitizer:string,
	system_include_dirs:list[file],
	warnings:list[string]
];

default_compile_options:Options = record
{
	debug = false;
	definitions = [];
	cflags = [];
	cxxflags = [];
	include_dirs = [];
	optlevel = 2;
	pic = true;
	sanitizer = '';
	system_include_dirs = files(/usr/include);
	warnings = [];
};

compile_flags = function(opts:Options, cxx:bool=false,
                         extra_header_dirs:list[file]=[]): list[string]
{
	include_dirs = opts.include_dirs + extra_header_dirs;

	(if opts.debug '-g' else '')
	::
	('-O' + string(opts.optlevel))
	::
	(if opts.pic '-fPIC' else '')
	::
	(if opts.sanitizer != '' ['-fsanitize=' + opts.sanitizer] else [])
	+
	(if cxx opts.cxxflags else opts.cflags)
	+
	(foreach dir <- include_dirs '-I' + dir.fullname)
	+
	(foreach dir <- opts.system_include_dirs '-isystem ' + dir.fullname)
	+
	(foreach warning <- opts.warnings '-W' + warning)
	+
	(foreach define <- opts.definitions '-D' + define)
};

binary_flags = function(opts:Options, dynamic:bool=false): list[string]
{
	(if opts.debug ['-g'] else [])
	+
	(if opts.sanitizer != '' ['-fsanitize=' + opts.sanitizer] else [])
	+
	(if dynamic and platform.posix ['-rdynamic'] else [])
	+
	(foreach lib <- opts.libraries '-l' + lib)
};

library_flags = function(shared_library:bool): list[string]
{
	(if platform.darwin ['-Wl,-undefined' '-Wl,dynamic_lookup'] else [])
	+
	(if shared_library ['-shared'] else [])
};

# Get information about the current platform (POSIX? Darwin? Windows?)
platform = import('platform');


#
# Compile some number of source files into their corresponding object files.
#
compile = function(compilers:Compilers,
                   srcs:list[file],
                   options:Options,
                   extra_flags:list[string]=[],
                   extra_header_dirs:list[file]=[],
                   dependencies:list[file[in]]=[]
	): list[file]
{
	# Compile each source file into a corresponding object file and accumulate
	# all of the object files into a list.
	foreach src <- srcs {
		cxx = not src.extension == 'c';
		obj = src + '.o';
		includes = extra_header_dirs + (src.includes ? []);
		compiler = if cxx compilers.cxx else compilers.cc;

		flags = compile_flags(options, cxx, includes)
			+ extra_flags
			+ (src.cxxflags ? []);

		compile_one(compiler, src, obj, flags, dependencies);
		obj
	}
};


#
# Compile objects into a shared library given by libname (e.g., `foo` for `libfoo.so`).
#
library = function(compiler:file, objects:list[file], libname:string, subdir:file,
                   shared:bool, extra_flags:list[string]=[]): file
{
	filename = file(library_name(libname), subdir=subdir);
	flags = library_flags(shared) + extra_flags;

	link_library(compiler, objects, filename, flags)
};


#
# What should a library be called on this platform?
#
library_name = function(name:string): string
{
	if platform.darwin
		'lib' + name + '.dylib'

	else if platform.posix
		'lib' + name + '.so'

	else
		name + '.dll'
};


#
# Where supported, treat system header directories differently from other include dirs:
# suppress warnings in files that we aren't responsible for.
#
system_headers = function(dirs:list[file]): list[string]
{
	foreach dir <- dirs
	{
		'-isystem ' + dir.fullname
	}
};


#
# Low-level rules:
#

# Compile one source file into one object file.
compile_one = action('${compiler} -c ${flags} -MMD -MF ${obj}.d ${src} -o ${obj}',
	     description = 'Compiling ${obj}', depfile = '${obj}.d'
	     <- compiler:file[in], src:file[in], obj:file[out], flags:list[string],
	        otherDeps:list[file[in]] = [], dependencies:string = '');

# Link object files into an executable binary.
link_binary = action(
	'${compiler} -o ${binary} ${objects} ${flags}', description = 'Linking ${binary}'
	<- compiler:file[in], objects:list[file[in]], binary:file[out], flags:list[string]
);

# Low-level rule for compiling objects into a shared library.
link_library = action(
	'${compiler} -shared -o ${library} ${objects} ${flags}',
	description = 'Linking ${library}'
        <- compiler:file[in], objects:list[file[in]], library:file[out],
	   flags:list[string]);
