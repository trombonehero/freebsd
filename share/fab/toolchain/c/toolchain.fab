#
# Description of a C/C++ toolchain
#

#
# Options represent compiler flags in a more structured way.
#
Options = type record
[
	debug:bool,
	definitions:list[string],
	cflags:list[string],
	cxxflags:list[string],
	include_dirs:list[file],
	optlevel:int,
	pic:bool,
	sanitizer:string,
	system_include_dirs:list[file],
	warnings:list[string]
];

#
# A function that can process C/C++ options and turn them into compiler arguments.
#
# Parameters:
#  - C/C++ compilation options
#  - whether or not we are compiling with C++
#
# Result:
#  - a list of command-line arguments
#
OptionsProcessor = type (Options, bool)->list[string];

#
# A function that compiles a single source file.
#
# Parameters:
#  - a source file
#  - compiler options
#  - (extra) flags
#  - (extra) include directories
#  - (extra) dependencies
#
# Result:
#  - a compiled object file
#
CompileOne = type (file[in], Options, list[string], list[file[in]], list[file[in]])->file;

#
# A function that compiles a single source file.
#
# Parameters:
#  - a list of source files
#  - compiler options
#  - (extra) flags
#  - (extra) include directories
#  - (extra) dependencies
#
# Result:
#  - a list of compiled object files
#
CompileSome = type
	(list[file[in]], Options, list[string], list[file[in]], list[file[in]])->list[file];

Toolchain = type record
[
	compile_src:CompileOne,
	compile_srcs:CompileSome,
	#link_binary:(list[file[in]], string, file, bool, list[string])->file,
	#link_shared_library:(list[file[in]], string, file, bool, list[string])->file,
];


create = function(default_options:Options,
                  compile_one:(file, Options, list[file])->file,
                  binflags:OptionsProcessor, libflags:OptionsProcessor): Toolchain
{
	record
	{
		# Compile a single source file into a corresponding object file
		compile_src = function(src:file[in],
		                       options:Options=default_options,
		                       extra_flags:list[string],
		                       extra_header_dirs:list[file[in]],
		                       dependencies:list[file[in]])
			: file
		{
			all_extra_includes = extra_header_dirs + (src.includes ? []);

			# TODO: record merging
			opts:Options = record
			{
				debug = options.debug;
				definitions = options.definitions;
				cflags = options.cflags + src.cflags ? [];
				cxxflags = options.cxxflags + src.cxxflags ? [];
				include_dirs = options.include_dirs + all_extra_includes;
				optlevel = options.optlevel;
				pic = options.pic;
				sanitizer = options.sanitizer;
				system_include_dirs = options.system_include_dirs;
				warnings = options.warnings;
			};

			compile_one(src, opts, dependencies)
		};

		compile_srcs = function(srcs:list[file[in]],
		                        opts:Options=default_options,
		                        flags:list[string]=[],
		                        header_dirs:list[file[in]]=files(),
		                        deps:list[file[in]]=files())
			: list[file]
		{
			for src in srcs
			{
				compile_src(src, opts, flags, header_dirs, deps)
			}
		};
	}
};
